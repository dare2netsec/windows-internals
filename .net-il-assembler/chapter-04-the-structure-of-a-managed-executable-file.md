# Chapter 4: The Structure of a Managed Executable File

- the file format of a managed module is an extension of the standard Microsoft Windows Portable Executable and Common Object File Format (__PE/COFF__). Thus, formally, any managed module is a proper PE/COFF file, with additional features that identify it as a managed executable file.
<p align="center"><img src="https://i.imgur.com/SfPRKBq.png" width="350px" height="auto"></p>

## PE/COFF Headers

the IL assembler generates the following sections in a PE file:
- `.text`: A read-only section containing the common language runtime header, the metadata, the IL code, managed exception handling information, and managed resources
- `.sdata`: A read/write section containing data
- `.reloc`: A read-only section containing relocations
- `.rsrc`: A read-only section containing unmanaged resources
- `.tls`: A read/write section containing thread local storage data.

## Common Language Runtime Header

- skipped the COM header and flags definitions.

### EntryPointToken

-  contains a token (metadata identifier) of either a method definition (MethodDef) or a file reference (File).
- a __MethodDef token__ identifies a method defined in the module (a managed PE file) as the entry point method.
- a __File token__ is used in one case only: in the runtime header of the prime module of a multimodule assembly, when the entry point method is defined in another module (identified by the file reference) of this assembly. In this case, the module identified by the file reference must contain the respective MethodDef token in the EntryPointToken field of its runtime header.
- The method referred to by the EntryPointToken/EntryPointRVA field of the common language runtime header has nothing to do with the function to which the _AddressOfEntryPoint_ field of the PE header points. AddressOfEntryPoint always points to the __runtime invocation stub__, which is invisible to the runtime, is not reflected
in metadata and hence cannot have a token.

### VTableFixups Field

- is a data directory containing the RVA and the size of the image file’s v-table fixup table.
- managed and unmanaged methods use different data formats, so when a __managed method must be called from unmanaged code__, the common language runtime creates a marshaling thunk for it, which performs the data conversions, and the address of this thunk is placed in the respective address table.
- if the managed method is called from the unmanaged code embedded in the current managed PE file, the thunk address goes to the file’s v-table.

### StrongNameSignature Field

- contains the RVA and size of the __strong name hash__, which is used by the runtime to establish the authenticity of the image file.
- after the image file has been created, it is hashed using the private encryption keys provided by the producer of the image file, and the resulting hash blob is written into the space allocated inside the image file.
- if even a single byte in the image file is subsequently modified, the authenticity check fails, and the image file cannot be loaded.

### Relocation Section

- the only fixup type emitted by the existing managed compilers in 32-bit executables is `IMAGE_REL_BASED_HIGHLOW`. In 64-bit executables, it is `IMAGE_REL_BASED_DIR64`.
- A 32-bit pure-IL PE file, as a rule, contains only __one fixup__ in the .reloc section. This is for the benefit of the common language runtime __start-up stub__, the only segment of native code in a pure-IL image file. This fixup is for the image file’s IAT, containing a single entry: the __CLR entry point__.
- A 64-bit pure-IL PE file contains one fixup on X64 architecture and two fixups on Itanium architecture (additional fixup needed for the global pointer).
- Windows XP or newer, as a common language runtime–aware operating system, needs neither the runtime start-up stub nor the IAT to invoke the runtime. Thus, if the common language runtime header flags indicate that the image file is IL only (`COMIMAGE_FLAGS_ILONLY`), the operating system ignores the `.reloc` section altogether.

### Text Section

- structure of a `.text` section emitted by the IL assembler:
<p align="center"><img src="https://i.imgur.com/N5ko4RG.png" width="350px" height="auto"></p>

### Data Sections

- data section (.sdata) of an image file generated by the IL assembler is a read/write section. It contains __data constants__, the __v-table__ described in the “V-Table” section, the __unmanaged export table__, and the __thread local storage__ directory structure. The data declared as thread-specific is located in a different section, the `.tls` section.

### Data Constants

- the term __data constants__ might be a little __misleading__. Located in a read/write section, data constants can certainly be __overwritten__, so technically they can hardly be called constants.
- data constants represent the __mappings of the static fields__ and usually contain data initializing the mapped fields.
- field mapping is a convenient way to initialize any static field with ANSI strings, blobs, or structures. An alternative way to initialize static fields—and a more orthodox way in terms of the common language runtime—is to do it explicitly by executing code in __class constructors__.

### V-Table

- the v-table in a pure-managed module is used for __exposing the managed methods for consumption from the unmanaged code__ and consists of entries, each entry consisting of one or more slots.
- each slot of the v-table contains a __metadata token__ of the respective method, which at execution time is replaced with the address of the method itself or the address of a marshaling thunk providing unmanaged entry to the method.

### Unmanaged Export Table

- the unmanaged export table in an unmanaged image file occupies a separate section named `.edata`. In image files generated by the IL assembler, the unmanaged export table resides in the `.sdata` section, together with the v-table it references.
- in a managed file, the Export Address table contains the RVAs not of the exported entry points (methods) themselves but rather of __unmanaged export stubs__ giving access to these entry points. Export stubs, in turn, contain references to respective v-table slots.
- The IL assembler __does not allow forward exports__, so the entries in an Export Address table of an image file generated by this compiler always represent the RVAs of unmanaged export stubs.
- IL assembler does not allow unnamed exports.

### Thread Local Storage

- ILAsm and VC++ allow you to define data constants belonging to thread local storage and to map static fields to these data constants.

### Resources

- you can embed two distinct kinds of resources in a managed PE file: __unmanaged platform-specific__ resources and __managed resources specific to CLR__.
- these two kinds of resources, which have nothing in common, reside in different
sections of a managed image file and are accessed by different sets of APIs.

### Unmanaged Resources

- unmanaged resources (reside in `.rsrc` section) are indexed by __type, name, and language__ and are binary sorted by these three characteristics in that order.
- a set of Resource directory tables represents this indexing as follows: each directory table is followed by an array of directory entries, which contain the integer reference number (ID) or name of the respective level (the type, name, or language level) and the address of the next-level directory table or of a data description (a leaf node of the tree).

### Managed Resources

- the Resources field of the CLR header contains the RVA and size of the managed resources embedded in the PE file. It has nothing to do with the Resource directory of the PE header, which specifies the RVA and size of unmanaged platform-specific resources.
- managed resources are stored in the `.text` section contiguously.
- metadata carries __ManifestResource__ records, one for each managed resource, containing the name of the managed resource and the offset of the beginning of the resource from the starting RVA specified in the Resources field of the CLR header.

## Summary

- Steps the IL assembler takes to create a managed PE file:
- __Phase 1: Initialization__
    - Internal buffers are initialized.
    - The empty template of a PE file is created in memory, including an MS-DOS header and stub, a PE signature, a COFF header, and a PE header.
    - The Import Address table and the CLR header are allocated in the .text section.
- __Phase 2: Source Code Parsing__
    - Metadata is collected in internal buffers.
    - The method bodies (IL code and managed exception handling tables) are collected in
internal buffers.
    - Data constants are emitted to the .sdata and .tls sections.
- __Phase 3: Image Generation__
    - Space for the strong name signature is allocated in the .text section.
    - Metadata is analyzed and rearranged.
    - Internal (to the module) references are resolved in the IL code.
    - Method bodies are emitted to the .text section.
    - The TLS directory table is emitted to the .sdata section.
    - The debug directory is emitted to the .text section.
    - Space for metadata is allocated in the .text section.
    - Space for embedded managed resources is allocated in the .text section.
    - Unmanaged export stubs are emitted to the .text section.
    - The VTFixup table is emitted to the .text section.
    - The v-table is emitted to the .sdata section.
    - Unmanaged export tables are emitted to the .sdata section.
    - Last changes in the metadata—the RVAs of mapped fields are fixed up.
    - Metadata is emitted into the preallocated space in the .text section.
    - Managed resources are emitted into the preallocated space in the .text section.
    - The runtime start-up stub is emitted to the .text section.
    - Unmanaged resources are read from the .res file and emitted to the .rsrc section.
    - Necessary base relocations are emitted to the .reloc section.
- __Phase 4: Completion__
    - The image file is written as a disk file.
    - The strong name signing procedure is applied to the file by invoking the strong name utility (sn.exe).

# Metadata Tables Organization

## What Is Metadata?

- in the context of the CLR, metadata means a __system of descriptors of all items__ that are declared or referenced in a module.
- the CLR programming model is inherently object oriented, so the items represented in metadata are __classes and their members__, with their accompanying __attributes, properties, and relationships__.
- metadata is an integral part of a managed module, which means each managed module always carries a complete, high-level, formal description of its logical structure.
- structurally, metadata is a __normalized relational database__. This means that metadata is organized as a set of __cross-referencing__ rectangular tables—as opposed to, for example, a hierarchical database that has a tree structure.
- each column of a metadata table contains __either data__ or a __reference__ to a row of another table. Metadata does not contain any duplicate data fields; each category of data resides in only one table of the metadata database. If another table needs to employ the same data, it references the table that holds the data.
- an example of optimized metadata:<p align="center"><img src="https://i.imgur.com/HAGIZWS.png" width="400px" height="auto"></p>
- it is possible, however (perhaps as a result of sloppy metadata emission or of incremental compilation), to have the child tables interleaved with regard to their owner classes. In such a case, additional intermediate metadata tables are engaged, providing noninterleaved lookup tables sorted by the owner class. Instead of referencing the method records, class records reference the records of an __intermediate table (a pointer table)__, and those records in turn reference the method records, as diagrammed below. Metadata that uses such intermediate lookup tables is referred to as __unoptimized or uncompressed__: <p align="center"><img src="https://i.imgur.com/HSV8hjI.png" width="400px" height="auto"></p>

## Heaps and Tables

- logically, metadata is represented as a set of __named streams__, with each stream representing a category of metadata.
- these streams are divided into two types: __metadata heaps__ and __metadata tables__.

### Heaps

- metadata heap is a storage of __trivial structure__, holding a __contiguous sequence of items__.
- heaps are used in metadata to store __strings and binary objects__.
- there are three kinds of metadata heaps:
    - __String heap__: This kind of heap contains __zero-terminated character strings__, encoded in UTF-8.
    - __GUID heap__: This kind of heap contains __16-byte binary objects__, immediately following each other. The size of the binary objects is fixed.
    - __Blob heap__: This kind of heap contains binary objects of __arbitrary__ size.

### General Metadata Header

- the general metadata header consists of a __storage signature__ and a __storage header__.
- six named streams can be present in the metadata:
    - __#Strings__: A string heap containing the names of metadata items (class names, method names, field names, and so on). The stream does not contain literal constants defined or referenced in the methods of the module.
    - __#Blob__: A blob heap containing internal metadata binary objects, such as default values, signatures, and so on.
    - __#GUID__: A GUID heap containing all sorts of globally unique identifiers.
    -  __#US__: A blob heap containing user-defined strings. This stream contains string constants defined in the user code.
    - __#~__: A compressed (optimized) metadata stream. This stream contains an optimized system of metadata tables.
    - __#-__: An uncompressed (unoptimized) metadata stream. This stream contains an unoptimized system of metadata tables, which includes at least one intermediate lookup table (pointer table).
- the figure on the __left__ side illustrates the _general structure of metadata_, and in the one in the __right__ side, you can see the way _streams are referenced by other streams_ as well as by external “consumers” such as metadata APIs and the IL code: <p align="center"><img src="https://i.imgur.com/fHmklf8.png" width="700px" height="auto"></p>

### Metadata Table Streams
